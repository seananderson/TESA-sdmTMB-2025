<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Families in sdmTMB</title>
    <meta charset="utf-8" />
    <meta name="author" content="" />
    <script src="libs/header-attrs-2.30/header-attrs.js"></script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
    <link rel="stylesheet" href="theme.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Families in sdmTMB
]
.subtitle[
## DFO TESA sdmTMB workshop
]
.author[
### 
]
.date[
### November 4â€“6 2025
]

---


&lt;!-- Build with: xaringan::inf_mr() --&gt;





# Families

Many of the same families used in `glm()`, `glmmTMB()`, `mgcv::gam()` can be used here

Includes:
  `gaussian()`, `Gamma()`, 
  `binomial()`, `poisson()`, `Beta()`, 
  `student()`, `tweedie()`, 
  `nbinom1()`, `nbinom2()`,
  `truncated_nbinom1()`, `truncated_nbinom2()`,
  `delta_gamma()`, `delta_lognormal()`, `delta_beta()`, and more...
  
All have `link` arguments
  
See `?sdmTMB::Families`

---
&lt;!-- These are exported dimensions from Powerpoint * 80% --&gt;
.center[
&lt;img src="images/family_diagram.png" width="800px" height = "450px"/&gt;
 
*New distributions continue to be added  

]

---

# Tweedie distribution

.small[
Useful for positive continuous data with zeros (e.g., biomass density per unit effort) 

Dispersion ( `\(\phi\)` ) and power ( `\(p\)` ) parameters allow for a wide variety of shapes including many zeros

Also known as compound Poisson-Gamma distribution
]

&lt;img src="07-families_files/figure-html/sim-tweedie-1.png" width="400px" style="display: block; margin: auto;" /&gt;

---

# Generalized gamma distribution

.small[
Useful for positive continuous data

Can match the gamma or approach the lognormal

Can also be lighter tailed than the gamma, in between, or heavier tailed than the lognormal

All for one extra paramater, "Q"
]

.tiny[
Dunic, J.C., Conner, J., Anderson, S.C., and Thorson, J.T. 2025. The generalized gamma is a flexible distribution that outperforms alternatives when modelling catch rate data. ICES Journal of Marine Science 82(4): fsaf040. &lt;https://doi.org/10.1093/icesjms/fsaf040&gt;
]

---

# Generalized gamma distribution

.center[
&lt;img src="images/gengamma.jpg" width="600px"/&gt;
]

.tiny[
Dunic, J.C., Conner, J., Anderson, S.C., and Thorson, J.T. 2025. The generalized gamma is a flexible distribution that outperforms alternatives when modelling catch rate data. ICES Journal of Marine Science 82(4): fsaf040. &lt;https://doi.org/10.1093/icesjms/fsaf040&gt;
]

---

# Standard delta models

Also known as "hurdle" models

* Delta/hurdle model has 2 sub-components ("linear predictors"):
  - presence/absence  
  - positive model

* many delta- families implemented: `delta_gamma()`, `delta_lognormal()`, `delta_gengamma()` etc  

---

# Poisson-link delta models

Addresses several shortcomings of standard delta models:
  - Linear predictors are additive
  - Can be used to combine weight, count, and encounter data

Often just fits the data better

E.g., `delta_gamma(type = "poisson-link")`

.small[
Vignette:&lt;br&gt;
&lt;https://pbs-assess.github.io/sdmTMB/articles/poisson-link.html&gt;
]

---

# Poisson-link delta models

Linear predictors represent:
  - log numbers density
  - log weight per "group"

Before entering the likelihood, these get transformed internally as:
  - probability of encounter
  - positive catch rate given encounter

---

# Poisson-link delta models

What do we mean by linear predictors?

$$
`\begin{aligned}
\log (n) &amp;= \boldsymbol{X_1} \boldsymbol{\beta_1} + \ldots,\\
\log (w) &amp;= \boldsymbol{X_2} \boldsymbol{\beta_2} + \ldots,
\end{aligned}`
$$
  
- `\(n\)` represents group **n**umbers density
- `\(w\)` represents **w**eight per group

---

## What do we mean by *linear predictors are additive*

Standard delta model:

.center[
&lt;img src="images/delta-standard-curve.png" width="550px" /&gt;
]

---

## What do we mean by *linear predictors are additive*

Poisson link delta model:

.center[
&lt;img src="images/delta-poissonlink-curve.png" width="550px" /&gt;
]

---

# Poisson-link delta models

From linear predictors to data likelihood:

$$
`\begin{aligned}
p &amp;= 1 - \exp(-n),\\
r &amp;= \frac{n w}{p},
\end{aligned}`
$$
  
- `\(p\)` represents encounter **p**robability
- `\(n\)` represents group **n**umbers density
- `\(r\)` represents positive catch **r**ate (i.e., catch rate given encounter)
- `\(w\)` represents **w**eight per group.

---

# sdmTMB delta model arguments

Some arguments can be a list:


``` r
fit &lt;- sdmTMB(
  list(
    density ~ 1, 
    density ~ depth
  ),
  family = delta_gamma(),
  spatial = list('on', 'off'),  
  spatiotemporal = list('off', 'ar1'), 
  share_range = list(TRUE, FALSE),
  ...
)
```

.small[
* by default, all arguments shared  
* all other arguments must be shared
* smoothers and random intercepts/slopes must be shared
]

---

# An aside on mixture models

Positive components may be modeled as a mixture of 2 distributions

* Finite mixture model (2 components)  

* Also referred to as "ECE" (extreme catch event) model, Thorson et al. (2012)  

* Mechanisms: shoaling, etc.  

* See `gamma_mix()` and `lognormal_mix()`

* Can be delta model as `delta_gamma_mix()` and `delta_lognormal_mix()`
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
  "highlightLines": true,
  "countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
